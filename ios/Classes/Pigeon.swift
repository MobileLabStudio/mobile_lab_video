// Autogenerated from Pigeon (v4.2.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif


/// Generated class from Pigeon.

enum VideoPlayerError: Int {
  case unknown = 0
  case serverDied = 1
  case io = 2
  case malformed = 3
  case unsupported = 4
  case timedOut = 5
  case system = 6
}

///Generated class from Pigeon that represents data sent in messages.
struct VideoDetails {
  var width: Int32
  var height: Int32
  var surfaceId: Int32

  static func fromMap(_ map: [String: Any?]) -> VideoDetails? {
    let width = map["width"] as! Int32
    let height = map["height"] as! Int32
    let surfaceId = map["surfaceId"] as! Int32

    return VideoDetails(
      width: width,
      height: height,
      surfaceId: surfaceId
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "width": width,
      "height": height,
      "surfaceId": surfaceId
    ]
  }
}

private class VideoPlayerApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return VideoDetails.fromMap(self.readValue() as! [String: Any])      
      default:
        return super.readValue(ofType: type)
      
    }
  }
}
private class VideoPlayerApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? VideoDetails {
      super.writeByte(128)
      super.writeValue(value.toMap())
    } else {
      super.writeValue(value)
    }
  }
}

private class VideoPlayerApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return VideoPlayerApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return VideoPlayerApiCodecWriter(data: data)
  }
}

class VideoPlayerApiCodec: FlutterStandardMessageCodec {
  static let shared = VideoPlayerApiCodec(readerWriter: VideoPlayerApiCodecReaderWriter())
}

///Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol VideoPlayerApi {
  func prepare(completion: @escaping (VideoDetails) -> Void)
  func play()
  func pause()
  func release()
  func seekTo(milliseconds: Int32)
  func reset()
  func isPlaying() -> Bool
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class VideoPlayerApiSetup {
  /// The codec used by VideoPlayerApi.
  static var codec: FlutterStandardMessageCodec { VideoPlayerApiCodec.shared }
  /// Sets up an instance of `VideoPlayerApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: VideoPlayerApi?) {
    let prepareChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerApi.prepare", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      prepareChannel.setMessageHandler { _, reply in
        api.prepare() { result in
          reply(wrapResult(result))
        }
      }
    } else {
      prepareChannel.setMessageHandler(nil)
    }
    let playChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerApi.play", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      playChannel.setMessageHandler { _, reply in
        api.play()
        reply(nil)
      }
    } else {
      playChannel.setMessageHandler(nil)
    }
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerApi.pause", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { _, reply in
        api.pause()
        reply(nil)
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    let releaseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerApi.release", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      releaseChannel.setMessageHandler { _, reply in
        api.release()
        reply(nil)
      }
    } else {
      releaseChannel.setMessageHandler(nil)
    }
    let seekToChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerApi.seekTo", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      seekToChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let millisecondsArg = args[0] as! Int32
        api.seekTo(milliseconds: millisecondsArg)
        reply(nil)
      }
    } else {
      seekToChannel.setMessageHandler(nil)
    }
    let resetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerApi.reset", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      resetChannel.setMessageHandler { _, reply in
        api.reset()
        reply(nil)
      }
    } else {
      resetChannel.setMessageHandler(nil)
    }
    let isPlayingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerApi.isPlaying", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isPlayingChannel.setMessageHandler { _, reply in
        let result = api.isPlaying()
        reply(wrapResult(result))
      }
    } else {
      isPlayingChannel.setMessageHandler(nil)
    }
  }
}
private class VideoPlayerDelegateApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return VideoDetails.fromMap(self.readValue() as! [String: Any])      
      default:
        return super.readValue(ofType: type)
      
    }
  }
}
private class VideoPlayerDelegateApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? VideoDetails {
      super.writeByte(128)
      super.writeValue(value.toMap())
    } else {
      super.writeValue(value)
    }
  }
}

private class VideoPlayerDelegateApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return VideoPlayerDelegateApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return VideoPlayerDelegateApiCodecWriter(data: data)
  }
}

class VideoPlayerDelegateApiCodec: FlutterStandardMessageCodec {
  static let shared = VideoPlayerDelegateApiCodec(readerWriter: VideoPlayerDelegateApiCodecReaderWriter())
}

///Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol VideoPlayerDelegateApi {
  func create(uri: String) -> String
  func prepare(playerId: String, completion: @escaping (VideoDetails) -> Void)
  func play(playerId: String)
  func pause(playerId: String)
  func release(playerId: String)
  func seekTo(milliseconds: Int32, playerId: String)
  func reset(playerId: String)
  func isPlaying(playerId: String, completion: @escaping (Bool) -> Void)
  func releaseAll()
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class VideoPlayerDelegateApiSetup {
  /// The codec used by VideoPlayerDelegateApi.
  static var codec: FlutterStandardMessageCodec { VideoPlayerDelegateApiCodec.shared }
  /// Sets up an instance of `VideoPlayerDelegateApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: VideoPlayerDelegateApi?) {
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.create", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let uriArg = args[0] as! String
        let result = api.create(uri: uriArg)
        reply(wrapResult(result))
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    let prepareChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.prepare", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      prepareChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! String
        api.prepare(playerId: playerIdArg) { result in
          reply(wrapResult(result))
        }
      }
    } else {
      prepareChannel.setMessageHandler(nil)
    }
    let playChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.play", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      playChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! String
        api.play(playerId: playerIdArg)
        reply(nil)
      }
    } else {
      playChannel.setMessageHandler(nil)
    }
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.pause", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! String
        api.pause(playerId: playerIdArg)
        reply(nil)
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    let releaseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.release", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      releaseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! String
        api.release(playerId: playerIdArg)
        reply(nil)
      }
    } else {
      releaseChannel.setMessageHandler(nil)
    }
    let seekToChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.seekTo", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      seekToChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let millisecondsArg = args[0] as! Int32
        let playerIdArg = args[1] as! String
        api.seekTo(milliseconds: millisecondsArg, playerId: playerIdArg)
        reply(nil)
      }
    } else {
      seekToChannel.setMessageHandler(nil)
    }
    let resetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.reset", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      resetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! String
        api.reset(playerId: playerIdArg)
        reply(nil)
      }
    } else {
      resetChannel.setMessageHandler(nil)
    }
    let isPlayingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.isPlaying", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isPlayingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! String
        api.isPlaying(playerId: playerIdArg) { result in
          reply(wrapResult(result))
        }
      }
    } else {
      isPlayingChannel.setMessageHandler(nil)
    }
    let releaseAllChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.releaseAll", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      releaseAllChannel.setMessageHandler { _, reply in
        api.releaseAll()
        reply(nil)
      }
    } else {
      releaseAllChannel.setMessageHandler(nil)
    }
  }
}
///Generated class from Pigeon that represents Flutter messages that can be called from Swift.
class FlutterVideoPlayerApi {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  /// Called when player enters error state.
  /// The [error] param is index of the [VideoPlayerError] enum.
  /// The [nativePlayerInfo] is info about player which enters error state
  func onError(error errorArg: Int32, surfaceId surfaceIdArg: Int32, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.FlutterVideoPlayerApi.onError", binaryMessenger: binaryMessenger)
    channel.sendMessage([errorArg, surfaceIdArg]) { _ in
      completion()
    }
  }
  /// Called when player buffer updates
  func onBuffering(percent percentArg: Int32, surfaceId surfaceIdArg: Int32, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.FlutterVideoPlayerApi.onBuffering", binaryMessenger: binaryMessenger)
    channel.sendMessage([percentArg, surfaceIdArg]) { _ in
      completion()
    }
  }
  /// Called when media completes
  func onCompleted(surfaceId surfaceIdArg: Int32, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.FlutterVideoPlayerApi.onCompleted", binaryMessenger: binaryMessenger)
    channel.sendMessage([surfaceIdArg]) { _ in
      completion()
    }
  }
  /// Called when player was prepared
  func onPrepared(surfaceId surfaceIdArg: Int32, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.FlutterVideoPlayerApi.onPrepared", binaryMessenger: binaryMessenger)
    channel.sendMessage([surfaceIdArg]) { _ in
      completion()
    }
  }
}

private func wrapResult(_ result: Any?) -> [String: Any?] {
  return ["result": result]
}

private func wrapError(_ error: FlutterError) -> [String: Any?] {
  return [
    "error": [
      "code": error.code,
      "message": error.message,
      "details": error.details
    ]
  ]
}
