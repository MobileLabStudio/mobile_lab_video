// Autogenerated from Pigeon (v10.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)"
  ]
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum VideoPlayerError: Int {
  case unknown = 0
  case serverDied = 1
  case io = 2
  case malformed = 3
  case unsupported = 4
  case timedOut = 5
  case system = 6
}

enum PMediaPlayerState: Int {
  case ready = 0
  case buffering = 1
  case ended = 2
  case idle = 3
}

/// Generated class from Pigeon that represents data sent in messages.
struct VideoDetails {
  var width: Int64
  var height: Int64
  var surfaceId: Int64

  static func fromList(_ list: [Any?]) -> VideoDetails? {
    let width = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let height = list[1] is Int64 ? list[1] as! Int64 : Int64(list[1] as! Int32)
    let surfaceId = list[2] is Int64 ? list[2] as! Int64 : Int64(list[2] as! Int32)

    return VideoDetails(
      width: width,
      height: height,
      surfaceId: surfaceId
    )
  }
  func toList() -> [Any?] {
    return [
      width,
      height,
      surfaceId,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PMediaPlayerInfo {
  var textureId: Int64

  static func fromList(_ list: [Any?]) -> PMediaPlayerInfo? {
    let textureId = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)

    return PMediaPlayerInfo(
      textureId: textureId
    )
  }
  func toList() -> [Any?] {
    return [
      textureId,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PVideoMeta {
  var width: Int64
  var height: Int64

  static func fromList(_ list: [Any?]) -> PVideoMeta? {
    let width = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let height = list[1] is Int64 ? list[1] as! Int64 : Int64(list[1] as! Int32)

    return PVideoMeta(
      width: width,
      height: height
    )
  }
  func toList() -> [Any?] {
    return [
      width,
      height,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PMediaPlayerStateEvent {
  var textureId: Int64
  var state: PMediaPlayerState

  static func fromList(_ list: [Any?]) -> PMediaPlayerStateEvent? {
    let textureId = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let state = PMediaPlayerState(rawValue: list[1] as! Int)!

    return PMediaPlayerStateEvent(
      textureId: textureId,
      state: state
    )
  }
  func toList() -> [Any?] {
    return [
      textureId,
      state.rawValue,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PMediaPlayerNaviteError {
  var textureId: Int64
  var details: [String?: Any?]

  static func fromList(_ list: [Any?]) -> PMediaPlayerNaviteError? {
    let textureId = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let details = list[1] as! [String?: Any?]

    return PMediaPlayerNaviteError(
      textureId: textureId,
      details: details
    )
  }
  func toList() -> [Any?] {
    return [
      textureId,
      details,
    ]
  }
}

private class VideoPlayerDelegateApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return VideoDetails.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class VideoPlayerDelegateApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? VideoDetails {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class VideoPlayerDelegateApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return VideoPlayerDelegateApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return VideoPlayerDelegateApiCodecWriter(data: data)
  }
}

class VideoPlayerDelegateApiCodec: FlutterStandardMessageCodec {
  static let shared = VideoPlayerDelegateApiCodec(readerWriter: VideoPlayerDelegateApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol VideoPlayerDelegateApi {
  func create(uri: String) throws -> String
  func prepare(playerId: String, completion: @escaping (Result<VideoDetails, Error>) -> Void)
  func play(playerId: String) throws
  func pause(playerId: String) throws
  func release(playerId: String) throws
  func seekTo(milliseconds: Int64, playerId: String) throws
  func reset(playerId: String) throws
  func isPlaying(playerId: String, completion: @escaping (Result<Bool, Error>) -> Void)
  func releaseAll() throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class VideoPlayerDelegateApiSetup {
  /// The codec used by VideoPlayerDelegateApi.
  static var codec: FlutterStandardMessageCodec { VideoPlayerDelegateApiCodec.shared }
  /// Sets up an instance of `VideoPlayerDelegateApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: VideoPlayerDelegateApi?) {
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.create", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let uriArg = args[0] as! String
        do {
          let result = try api.create(uri: uriArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    let prepareChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.prepare", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      prepareChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! String
        api.prepare(playerId: playerIdArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      prepareChannel.setMessageHandler(nil)
    }
    let playChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.play", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      playChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! String
        do {
          try api.play(playerId: playerIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      playChannel.setMessageHandler(nil)
    }
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.pause", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! String
        do {
          try api.pause(playerId: playerIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    let releaseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.release", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      releaseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! String
        do {
          try api.release(playerId: playerIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      releaseChannel.setMessageHandler(nil)
    }
    let seekToChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.seekTo", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      seekToChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let millisecondsArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let playerIdArg = args[1] as! String
        do {
          try api.seekTo(milliseconds: millisecondsArg, playerId: playerIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      seekToChannel.setMessageHandler(nil)
    }
    let resetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.reset", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      resetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! String
        do {
          try api.reset(playerId: playerIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      resetChannel.setMessageHandler(nil)
    }
    let isPlayingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.isPlaying", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isPlayingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! String
        api.isPlaying(playerId: playerIdArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      isPlayingChannel.setMessageHandler(nil)
    }
    let releaseAllChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.VideoPlayerDelegateApi.releaseAll", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      releaseAllChannel.setMessageHandler { _, reply in
        do {
          try api.releaseAll()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      releaseAllChannel.setMessageHandler(nil)
    }
  }
}
/// Generated class from Pigeon that represents Flutter messages that can be called from Swift.
class FlutterVideoPlayerApi {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  /// Called when player enters error state.
  /// The [error] param is index of the [VideoPlayerError] enum.
  /// The [nativePlayerInfo] is info about player which enters error state
  func onError(error errorArg: Int64, surfaceId surfaceIdArg: Int64, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.FlutterVideoPlayerApi.onError", binaryMessenger: binaryMessenger)
    channel.sendMessage([errorArg, surfaceIdArg] as [Any?]) { _ in
      completion()
    }
  }
  /// Called when player buffer updates
  func onBuffering(percent percentArg: Int64, surfaceId surfaceIdArg: Int64, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.FlutterVideoPlayerApi.onBuffering", binaryMessenger: binaryMessenger)
    channel.sendMessage([percentArg, surfaceIdArg] as [Any?]) { _ in
      completion()
    }
  }
  /// Called when media completes
  func onCompleted(surfaceId surfaceIdArg: Int64, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.FlutterVideoPlayerApi.onCompleted", binaryMessenger: binaryMessenger)
    channel.sendMessage([surfaceIdArg] as [Any?]) { _ in
      completion()
    }
  }
  /// Called when player was prepared
  func onPrepared(surfaceId surfaceIdArg: Int64, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.FlutterVideoPlayerApi.onPrepared", binaryMessenger: binaryMessenger)
    channel.sendMessage([surfaceIdArg] as [Any?]) { _ in
      completion()
    }
  }
}
private class PMediaPlayerFactoryCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return PMediaPlayerInfo.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class PMediaPlayerFactoryCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? PMediaPlayerInfo {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class PMediaPlayerFactoryCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return PMediaPlayerFactoryCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return PMediaPlayerFactoryCodecWriter(data: data)
  }
}

class PMediaPlayerFactoryCodec: FlutterStandardMessageCodec {
  static let shared = PMediaPlayerFactoryCodec(readerWriter: PMediaPlayerFactoryCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol PMediaPlayerFactory {
  func createHttpVideoPlayer(httpUrl: String, tag: String?, completion: @escaping (Result<PMediaPlayerInfo, Error>) -> Void)
  func createHLSVideoStream(hlsUrl: String, tag: String?, completion: @escaping (Result<PMediaPlayerInfo, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class PMediaPlayerFactorySetup {
  /// The codec used by PMediaPlayerFactory.
  static var codec: FlutterStandardMessageCodec { PMediaPlayerFactoryCodec.shared }
  /// Sets up an instance of `PMediaPlayerFactory` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: PMediaPlayerFactory?) {
    let createHttpVideoPlayerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayerFactory.createHttpVideoPlayer", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createHttpVideoPlayerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let httpUrlArg = args[0] as! String
        let tagArg: String? = nilOrValue(args[1])
        api.createHttpVideoPlayer(httpUrl: httpUrlArg, tag: tagArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      createHttpVideoPlayerChannel.setMessageHandler(nil)
    }
    let createHLSVideoStreamChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayerFactory.createHLSVideoStream", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createHLSVideoStreamChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let hlsUrlArg = args[0] as! String
        let tagArg: String? = nilOrValue(args[1])
        api.createHLSVideoStream(hlsUrl: hlsUrlArg, tag: tagArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      createHLSVideoStreamChannel.setMessageHandler(nil)
    }
  }
}
private class PMediaPlayerCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return PVideoMeta.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class PMediaPlayerCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? PVideoMeta {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class PMediaPlayerCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return PMediaPlayerCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return PMediaPlayerCodecWriter(data: data)
  }
}

class PMediaPlayerCodec: FlutterStandardMessageCodec {
  static let shared = PMediaPlayerCodec(readerWriter: PMediaPlayerCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol PMediaPlayer {
  func prepare() throws
  func play() throws
  func pause() throws
  func playPause() throws
  func seekTo(millisecond: Int64) throws
  func reuse() throws
  func release() throws
  func getVideoMeta() throws -> PVideoMeta
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class PMediaPlayerSetup {
  /// The codec used by PMediaPlayer.
  static var codec: FlutterStandardMessageCodec { PMediaPlayerCodec.shared }
  /// Sets up an instance of `PMediaPlayer` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: PMediaPlayer?) {
    let prepareChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayer.prepare", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      prepareChannel.setMessageHandler { _, reply in
        do {
          try api.prepare()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      prepareChannel.setMessageHandler(nil)
    }
    let playChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayer.play", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      playChannel.setMessageHandler { _, reply in
        do {
          try api.play()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      playChannel.setMessageHandler(nil)
    }
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayer.pause", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { _, reply in
        do {
          try api.pause()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    let playPauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayer.playPause", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      playPauseChannel.setMessageHandler { _, reply in
        do {
          try api.playPause()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      playPauseChannel.setMessageHandler(nil)
    }
    let seekToChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayer.seekTo", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      seekToChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let millisecondArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.seekTo(millisecond: millisecondArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      seekToChannel.setMessageHandler(nil)
    }
    let reuseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayer.reuse", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      reuseChannel.setMessageHandler { _, reply in
        do {
          try api.reuse()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      reuseChannel.setMessageHandler(nil)
    }
    let releaseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayer.release", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      releaseChannel.setMessageHandler { _, reply in
        do {
          try api.release()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      releaseChannel.setMessageHandler(nil)
    }
    let getVideoMetaChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayer.getVideoMeta", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoMetaChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getVideoMeta()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVideoMetaChannel.setMessageHandler(nil)
    }
  }
}
private class PMediaPlayerProxyCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return PMediaPlayerInfo.fromList(self.readValue() as! [Any?])
      case 129:
        return PVideoMeta.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class PMediaPlayerProxyCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? PMediaPlayerInfo {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? PVideoMeta {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class PMediaPlayerProxyCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return PMediaPlayerProxyCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return PMediaPlayerProxyCodecWriter(data: data)
  }
}

class PMediaPlayerProxyCodec: FlutterStandardMessageCodec {
  static let shared = PMediaPlayerProxyCodec(readerWriter: PMediaPlayerProxyCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol PMediaPlayerProxy {
  func prepare(mediaPlayerInfo: PMediaPlayerInfo) throws
  func play(mediaPlayerInfo: PMediaPlayerInfo) throws
  func pause(mediaPlayerInfo: PMediaPlayerInfo) throws
  func playPause(mediaPlayerInfo: PMediaPlayerInfo) throws
  func seekTo(mediaPlayerInfo: PMediaPlayerInfo, millisecond: Int64) throws
  func reuse(mediaPlayerInfo: PMediaPlayerInfo) throws
  func release(mediaPlayerInfo: PMediaPlayerInfo) throws
  func getVideoMeta(mediaPlayerInfo: PMediaPlayerInfo) throws -> PVideoMeta
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class PMediaPlayerProxySetup {
  /// The codec used by PMediaPlayerProxy.
  static var codec: FlutterStandardMessageCodec { PMediaPlayerProxyCodec.shared }
  /// Sets up an instance of `PMediaPlayerProxy` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: PMediaPlayerProxy?) {
    let prepareChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayerProxy.prepare", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      prepareChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let mediaPlayerInfoArg = args[0] as! PMediaPlayerInfo
        do {
          try api.prepare(mediaPlayerInfo: mediaPlayerInfoArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      prepareChannel.setMessageHandler(nil)
    }
    let playChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayerProxy.play", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      playChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let mediaPlayerInfoArg = args[0] as! PMediaPlayerInfo
        do {
          try api.play(mediaPlayerInfo: mediaPlayerInfoArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      playChannel.setMessageHandler(nil)
    }
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayerProxy.pause", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let mediaPlayerInfoArg = args[0] as! PMediaPlayerInfo
        do {
          try api.pause(mediaPlayerInfo: mediaPlayerInfoArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    let playPauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayerProxy.playPause", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      playPauseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let mediaPlayerInfoArg = args[0] as! PMediaPlayerInfo
        do {
          try api.playPause(mediaPlayerInfo: mediaPlayerInfoArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      playPauseChannel.setMessageHandler(nil)
    }
    let seekToChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayerProxy.seekTo", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      seekToChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let mediaPlayerInfoArg = args[0] as! PMediaPlayerInfo
        let millisecondArg = args[1] is Int64 ? args[1] as! Int64 : Int64(args[1] as! Int32)
        do {
          try api.seekTo(mediaPlayerInfo: mediaPlayerInfoArg, millisecond: millisecondArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      seekToChannel.setMessageHandler(nil)
    }
    let reuseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayerProxy.reuse", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      reuseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let mediaPlayerInfoArg = args[0] as! PMediaPlayerInfo
        do {
          try api.reuse(mediaPlayerInfo: mediaPlayerInfoArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      reuseChannel.setMessageHandler(nil)
    }
    let releaseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayerProxy.release", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      releaseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let mediaPlayerInfoArg = args[0] as! PMediaPlayerInfo
        do {
          try api.release(mediaPlayerInfo: mediaPlayerInfoArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      releaseChannel.setMessageHandler(nil)
    }
    let getVideoMetaChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayerProxy.getVideoMeta", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoMetaChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let mediaPlayerInfoArg = args[0] as! PMediaPlayerInfo
        do {
          let result = try api.getVideoMeta(mediaPlayerInfo: mediaPlayerInfoArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVideoMetaChannel.setMessageHandler(nil)
    }
  }
}
private class PMediaPlayerListenerCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return PMediaPlayerNaviteError.fromList(self.readValue() as! [Any?])
      case 129:
        return PMediaPlayerStateEvent.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class PMediaPlayerListenerCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? PMediaPlayerNaviteError {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? PMediaPlayerStateEvent {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class PMediaPlayerListenerCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return PMediaPlayerListenerCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return PMediaPlayerListenerCodecWriter(data: data)
  }
}

class PMediaPlayerListenerCodec: FlutterStandardMessageCodec {
  static let shared = PMediaPlayerListenerCodec(readerWriter: PMediaPlayerListenerCodecReaderWriter())
}

/// Generated class from Pigeon that represents Flutter messages that can be called from Swift.
class PMediaPlayerListener {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return PMediaPlayerListenerCodec.shared
  }
  func onStateChanged(stateEvent stateEventArg: PMediaPlayerStateEvent, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayerListener.onStateChanged", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([stateEventArg] as [Any?]) { _ in
      completion()
    }
  }
  func onError(naviteError naviteErrorArg: PMediaPlayerNaviteError, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.PMediaPlayerListener.onError", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([naviteErrorArg] as [Any?]) { _ in
      completion()
    }
  }
}
